number,comment
#12442,            
#12442,"See nodejs/CTC#12 for discussion/background. I would say that that thread is a better place for general discussion, and I prefer it if comments here would be kept to what is directly relevant for this PR. "
#12442,CI: https://ci.nodejs.org/job/node-test-commit/9143/ 
#12442,"Checklist   make -j4 test (UNIX), or vcbuild test (Windows) passes tests and/or benchmarks are included documentation is changed or added commit message follows commit guidelines "
#12442,Affected core subsystem(s) 
#12442,"util, timers "
#12442,Original commit descriptions 
#12442,util: add internal bindings for promise handling 
#12442,"Add methods for creating, resolving and rejecting promises using the V8 C++ API that does not require creation of extra resolve and reject functions to process.binding('util'). "
#12442,util: add util.promisify() 
#12442,Add util.promisify(function) for creating promisified functions. 
#12442,Fixes: nodejs/CTC#12 
#12442,timers: add promisify support 
#12442,Add support for util.promisify(setTimeout) and util.promisify(setImmediate) as a proof-of-concept implementation. clearTimeout() and clearImmediate() resolve the promise immediately instead of rejecting it; that might be the most opinionated choice about this. 
#12442,/cc @chrisdickinson @benjamingr @Fishrock123 @nodejs/ctc 
#12442,edit: CTC voting comment                  
#12442,"Also, @benjamingr has a good point about the naming, quote:  optimally I'd hope for most people to not even be aware of what a promise is in 5 years and just use async/await seamlessly :) "
#12442,"We can bikeshed this further here, but just to get an idea how people feel, could people ðŸ‘ this comment for â€œpromisify sounds goodâ€ and ðŸ‘Ž this for â€œIâ€™d prefer awaitable or something elseâ€ (both assuming that we agree on the approach in this PR in general)?                  "
#12442,Maybe we should split the timers bits into a second PR? They don't map well to promises since we don't have cancelables. Maybe we could plug the timers props onto the promise itself? Not sure.                  
#12442,"I.e. clearTimeout() should probably work on whatever setTimeoutPromise() returns (a promise but you get the idea), same for Immediates.                  "
#12442,"A big +1 on this. I think this could be a great first step for helping users deal with async/await in their code. There is a clear benefit over a userland implementation, and the need is prevalent.                  "
#12442,"Going to expand on my point a bit: I think this is reasonable to do for simple callback APIs but I think we should spend more* time to think about how to wrap more complex APIs such as timers, child processes, etc well.  * Might be good for an EP?                   Maybe we should split the timers bits into a second PR? "
#12442,"If thatâ€™s what people here prefer, sure. I just thought it made sense because theyâ€™re about the only API thatâ€™s a bit icky because they donâ€™t conform to Nodeâ€™s standard callback pattern, so whenever we introduce something like util.promisify() weâ€™d probably also want to have support for promisified timers (in some way).  I.e. clearTimeout() should probably work on whatever setTimeoutPromise() returns (a promise but you get the idea), same for Immediates. "
#12442,"Makes sense, Iâ€™ve updated the PR with isPromise(timer) checks anyway.                  "
#12442,"@Fishrock123  Going to expand on my point a bit: I think this is reasonable to do for simple callback APIs but I think we should spend more time to think about how to wrap more complex APIs such as timers, child processes, etc well. "
#12442,"I definitely agree - we need a proper promised core at some point - but #5020 and similar attempts have stagnated and quoting myself in the original issue:  The idea of util.awaitable vs a promise core is that it's hopefully a lot less objectionable, it poses a lot less controversy, it's a lot less opinionated and it means exposing a capability that users can build on and not an API.                  "
#12442,"I think @Fishrock123â€™s comment was about the timers stuff, not the general API here? I feel inclined to disagree that this needs an EP, thoughâ€¦                  "
#12442,Correct. I only mean for how to wrap any APIs that are more complex than single events or callbacks and which do not wrap as well.                  
#12442,"@TimothyGu Addressed most of your comments, PTAL                  "
#12442,"I just published https://www.npmjs.com/package/util.promisify (with code largely copy/pasted from this PR, with permission from @addaleax) for those interested.                    "
#12442,I (also) would like to see the timers impl in a followup PR.           
#12442,"This truthy test of orig is not needed since it is guaranteed to be a function at this point@williamkapke thanks for catching, donefunction isn't a legal identifier in JS, and for consistency we probably want to keep it legal.Lower case ""custom""I think the uppercase variant is okay here, itâ€™s referring to a literal section title, and it matches what we do for the other two section references in this file. If you feel strongly about it Iâ€™ll change it.An async function example would be cool as well.You probably want to clarify setImmediate() or its promisified equivalent.Ditto.""Using the util.promisify.custom symbol""?What about the prototype of orig?@TimothyGu yeah â€¦ that thought occurred to me, but I basically didnâ€™t see how setting it would make sense here. If you prefer, Iâ€™ll addYeah I don't see how it would matter that much in real world, but having that there does seem a bit more natural to me. Up to you if you want to set it or not.I don't think it would matter that much; it just occurred to me having the prototype being equivalent might be more natural. Up to you.@TimothyGu Iâ€™ve included it for now, letâ€™s see what people think.This seems like a bad idea for many reasons. I think it's fine if you can't cancel promisified timeout until we have some generic cancellation mechanism.This seems like a bad idea for many reasons.Would you care to provide some? Otherwise this is just not helpful.First of all, attaching properties to native objects seems like a bad idea from performance perspective. Secondly, this implements ad hoc cancellation mechanism, while there is no spec on standards track or even community consensus. This approach suffers from the fact that it's not propagated and there it doesn't play nice with async-await.I think it's fine to make promisified versions not cancellable. If you use them you are most likely not going to cancel anyway.First of all, attaching properties to native objects seems like a bad idea from performance perspective.Thatâ€™s true, but itâ€™s opt-in, right?This approach suffers from the fact that it's not propagatedWhat do you mean by propagated?But yeah, I would be okay with dropping clear* support for these, at least for the time being.What do you mean by propagated?Something like this:I have to agree with @vkurchatkin on this. Until there is a standard way of canceling promises, we likely shouldn't do this.@vkurchatkin @jasnell Okay, Iâ€™ve dropped clearTimeout/clearImmediate support. Itâ€™s a niche feature anyway and it should be easy to readjust later if we want.Nit: first may not be necessary hereYouâ€™re right. I wanted to phrase this error message in a way that makes it as unlikely as possible that changing it is semver-major, but if you prefer another wording, Iâ€™ll gladly change it. ðŸ˜„I was thinking maybe we can just drop first. When I read the error message, my mind understood that as there are more than one argument. Not a big deal though.There are few cases where we pass more than one value like in fs.readSo â€¦ if you like, I can check for those APIs and add custom code for them in this PR? I think that makes sense but maybe not everybody is comfortable with yet more changes in hereâ€¦We can use rest operator with data and with an if condition this can be fixed, right? Only thing is the resolved value will be an array for these special cases.@thefourtheye We have about 6 top-level functions doing that, Iâ€™ve taken a stab at addressing them in a clean way in this PR (see the most recent 3 commits)â€¦ please take a look :)If the original immediate was a promise not coming from setImmediate(), immediate should be undefined here, and this might crash. Not sure if we want that.This code doesnâ€™t have any typechecks right now anyway, you can just pass in anything and hope it doesnâ€™t go up in flames.I don't think it would matter that much; it just occurred to me having the prototype being equivalent might be more natural. Up to you.Is this function basically equivalent to passing a dummy function to the Promise constructor?I think so. Itâ€™s using V8s internal promise creation mechanism instead of the full Promise constructor â€¦ I would assume the latter is built upon the former, but I havenâ€™t checked that. If you want, I can try to look it up.This is internally implemented by basically calling new Promise() with no closure argument. However, the great thing is that, since you're using the V8 API, you can still resolve and reject it, even though no closures are allocated (because they won't leak).I'd make sure this doesn't decrease the performance of getting fn's properties; if in doubt, an if (Object.getPrototypeOf(fn) !== Object.getPrototypeOf(orig)) might be good.V8 implements setPrototypeOf as a no-op if they are already equal, Iâ€™ve checked that in the past to be sure. ðŸ˜„Promises are idempotent right? Should we really do this?It's to check that the promise is pending at that point. It might not be necessary but not because of idempotence.Hm, maybe it is necessary to always check for thatâ€¦ some really weird userland functions could schedule the callback to run and then throw after that. (And using this code would actually change the Promise state.)Iâ€™ve updated this to return as a no-op when the promise is not pending.Nice, this looks better than the throwing to me. Thanks :)This catch may accidentally catch errors thrown from promiseReject if orig.call happened to be synchronous. E.g. the value was cached in memory and didn't need a remote lookup. promiseReject on line 264 will be a no-op in that case.Ideally if the execution hit line 253 and then 264, it should re-throw the error instead of no-oping. At least it could log a warning.The existing way is definitely better; a function that returns a promise should never throw, only return a rejected promise.@syrnick can you please open an issue about it?(also, since a promise can only represent one value; new Promise((resolve, reject) => { reject(1); reject(2); }) is supposed to have the second rejection be a noop, and does not throw the 2, so it'd be important for util.promisify to maintain parity)What's the motivation for keeping this private? It's obviously useful in a number of places.https://github.com/nodejs/node/pull/12442/files#diff-a43208147d795be6dd3517c53226e37dR280 ?but that's still on internal/util, not accessible to user code. The other one(kCustomPromisifiedSymbol) is available as util.promisify.custom.@syrnick See #14007."
